<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>NU Land Parcel Map</title>
    <link rel="manifest" href="site.webmanifest" />
    <link rel="stylesheet" href="page.scss" />
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"
    />
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDNhC5KPQu7govGn9bXQOF1PE3mjKTrctg&libraries=visualization&callback=Function.prototype"></script>
    <style>
      html,
      body {
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <div id="map" class="map"></div>
    <script type="module">
      import geojson from "./data/complete.json";
      import * as mapStyles from "./config/map-style.json";

      function getScaledValue(
        value,
        sourceRangeMin,
        sourceRangeMax,
        targetRangeMin,
        targetRangeMax
      ) {
        var targetRange = targetRangeMax - targetRangeMin;
        var sourceRange = sourceRangeMax - sourceRangeMin;
        return (
          ((value - sourceRangeMin) * targetRange) / sourceRange +
          targetRangeMin
        );
      }

      const urlSearch = new URLSearchParams(window.location.search);

      // Determine the Size m2 range and scale the heatmap accordingly
      let min = 0;
      let max = 0;
      x = [];
      geojson["features"].forEach((feature) => {
        const area = parseInt(
          feature["properties"]["Size m2"].replace(/,/g, "")
        );
        feature["properties"]["Size m2"] = area;
        if (area > max) {
          max = area;
        }
        if (area < min) {
          min = area;
        }
      });

      let heatmapData = [];
      geojson["features"].forEach((feature) => {
        let lat = 0;
        let lng = 0;
        if (feature["geometry"]["type"] === "LineString") {
          lat = feature["geometry"]["coordinates"][0][1];
          lng = feature["geometry"]["coordinates"][0][0];
        } else if (feature["geometry"]["type"] === "MultiLineString") {
          lat = feature["geometry"]["coordinates"][0][0][1];
          lng = feature["geometry"]["coordinates"][0][0][0];
        }
        let latlng = new google.maps.LatLng(lat, lng);
        const scaledWeight = getScaledValue(
          feature["properties"]["Size m2"],
          min,
          max,
          0,
          100
        );
        heatmapData.push({
          location: latlng,
          weight: urlSearch.get("byarea") ? scaledWeight : 1,
          maxIntensity: 1,
        });
      });

      var center = new google.maps.LatLng(-34, 18.5241);

      map = new google.maps.Map(document.getElementById("map"), {
        center: center,
        zoom: 12,
        maxZoom: 14,
        type: "roadmap",
        styles: mapStyles,
        streetViewControl: false,
        fullscreenControl: false,
      });

      var heatmap = new google.maps.visualization.HeatmapLayer({
        data: heatmapData,
        radius: parseInt(urlSearch.get("radius")) || 25,
        gradient: [
          "rgba(0, 255, 255, 0)",
          "rgba(0, 255, 255, 1)",
          "rgba(0, 191, 255, 1)",
          "rgba(0, 127, 255, 1)",
          "rgba(0, 63, 255, 1)",
          "rgba(0, 0, 255, 1)",
          "rgba(0, 0, 223, 1)",
          "rgba(0, 0, 191, 1)",
          "rgba(0, 0, 159, 1)",
          "rgba(0, 0, 127, 1)",
          "rgba(63, 0, 91, 1)",
          "rgba(127, 0, 63, 1)",
          "rgba(191, 0, 31, 1)",
          "rgba(255, 0, 0, 1)",
        ],
        maxIntensity: parseInt(urlSearch.get("maxintensity")) || 75,
      });
      heatmap.setMap(map);
    </script>
  </body>
</html>
